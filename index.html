<!DOCTYPE html>
<html>
<head>
  <title>Group Voice Chat - v3</title>
</head>
<body>
  <h1>Group Voice Chat (v3)</h1>

  <input id="wssUrl" placeholder="Enter WSS URL (optional)" />
  <br><br>
  <button onclick="createRoom()">Create</button>
  <button onclick="joinRoom()">Join</button>
  <input id="roomCodeInput" placeholder="Enter room code..." />
  <p id="roomCodeDisplay"></p>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

  <script>
    let socket;
    let peerConnections = {}; // key: socket id, value: RTCPeerConnection
    let localStream;
    const servers = {
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    };

    async function getMedia() {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      console.log("Got local media stream");
    }

    async function initSocketConnection() {
      const urlInput = document.getElementById("wssUrl").value;
      const url = urlInput || 'wss://vc-test.onrender.com';
      socket = io(url);

      socket.on("connect", () => console.log("Connected to server"));

      socket.on("user-joined", async ({ userId }) => {
        console.log("User joined:", userId);
        if (!localStream) {
          console.warn("Local media not ready when user joined.");
          return;
        }

        if (peerConnections[userId]) return;

        const pc = createPeerConnection(userId);
        peerConnections[userId] = pc;

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit("offer", { to: userId, offer });
      });

      socket.on("offer", async ({ from, offer }) => {
        console.log("Received offer from", from);
        if (!localStream) {
          console.warn("Local media not ready when offer received.");
          return;
        }

        const pc = createPeerConnection(from);
        peerConnections[from] = pc;
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit("answer", { to: from, answer });
      });

      socket.on("answer", async ({ from, answer }) => {
  try {
    const pc = peerConnections[from];
    if (!pc) return;

    // Only set remote description if signalingState is not stable
    if (pc.signalingState !== "stable") {
      await pc.setRemoteDescription(new RTCSessionDescription(answer));
      console.log(`Set remote answer from ${from}`);
    } else {
      console.warn(`Skipped setting remote answer from ${from} because signalingState is stable`);
    }
  } catch (err) {
    console.error("Error setting remote answer:", err);
  }
});


      socket.on("ice-candidate", ({ from, candidate }) => {
        console.log("Received ICE candidate from", from);
        peerConnections[from]?.addIceCandidate(new RTCIceCandidate(candidate));
      });

      socket.on("peers", async ({ peers }) => {
  for (const userId of peers) {
    const pc = createPeerConnection(userId);
    peerConnections[userId] = pc;

    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    socket.emit("offer", { to: userId, offer });
  }
});


      socket.on("user-left", ({ userId }) => {
        console.log("User left:", userId);
        if (peerConnections[userId]) {
          peerConnections[userId].close();
          delete peerConnections[userId];
        }
      });
    }

    function createPeerConnection(userId) {
      const pc = new RTCPeerConnection(servers);

      pc.onicecandidate = e => {
        if (e.candidate) {
          socket.emit("ice-candidate", { to: userId, candidate: e.candidate });
        }
      };

      pc.ontrack = event => {
        console.log(`[${userId}] Receiving track:`, event.track.kind);
        let audio = document.getElementById("audio-" + userId);
        if (!audio) {
          audio = document.createElement("audio");
          audio.id = "audio-" + userId;
          audio.autoplay = true;
          document.body.appendChild(audio);
        }
        audio.srcObject = event.streams[0];
      };

      return pc;
    }

    async function createRoom() {
      await getMedia();
      await initSocketConnection();
      const roomCode = Math.random().toString(36).substr(2, 6).toUpperCase();
      document.getElementById("roomCodeDisplay").textContent = "Room Code: " + roomCode;
      socket.emit("create", roomCode);
      socket.emit("ready", roomCode);
    }

    async function joinRoom() {
      await getMedia();
      await initSocketConnection();
      const roomCode = document.getElementById("roomCodeInput").value.toUpperCase();
      socket.emit("join", roomCode);
      socket.emit("ready", roomCode);
    }
  </script>
</body>
</html>
