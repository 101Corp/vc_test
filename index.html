<!DOCTYPE html>
<html>
<head>
  <title>Group Voice Chat</title>
</head>
<body>
  <h1>Group Voice Chat</h1>

  <input id="wssUrl" placeholder="Enter WSS URL (optional)" />
  <br><br>
  <button onclick="createRoom()">Create</button>
  <button onclick="joinRoom()">Join</button>
  <input id="roomCodeInput" placeholder="Enter room code..." />
  <p id="roomCodeDisplay"></p>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"
    integrity="sha384-mZLF4UVrpi/QTWPA7BjNPEnkIfRFn4ZEO3Qt/HFklTJBj/gBOV8G3HcKn4NfQblz"
    crossorigin="anonymous"></script>

  <script>
    let socket;
    let peerConnections = {}; // { [userId]: RTCPeerConnection }
    let negotiationLocks = {}; // { [userId]: boolean }
    let localStream;

    const servers = {
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    };

    async function initSocketConnection() {
      const url = document.getElementById("wssUrl").value || location.origin.replace(/^http/, 'ws');
      socket = io(url);

      socket.on("connect", () => console.log("âœ… Connected to server"));

      socket.on("user-joined", async ({ userId }) => {
        console.log(`[${userId}] joined`);
        if (peerConnections[userId]) return;

        const pc = createPeerConnection(userId);
        peerConnections[userId] = pc;

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          socket.emit("offer", { to: userId, offer });
        } catch (err) {
          console.error(`[${userId}] Error creating offer:`, err);
        }
      });

      socket.on("offer", async ({ from, offer }) => {
        console.log(`[${from}] received offer`);

        let pc = peerConnections[from];
        if (!pc) {
          pc = createPeerConnection(from);
          peerConnections[from] = pc;
        }

        if (pc.signalingState !== "stable") {
          console.warn(`[${from}] Skipping offer: signaling state is ${pc.signalingState}`);
          return;
        }

        try {
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit("answer", { to: from, answer });
        } catch (err) {
          console.error(`[${from}] Error handling offer:`, err);
        }
      });

      socket.on("answer", async ({ from, answer }) => {
        const pc = peerConnections[from];
        if (!pc) return;
        try {
          await pc.setRemoteDescription(new RTCSessionDescription(answer));
        } catch (err) {
          console.error(`[${from}] Error setting remote answer:`, err);
        }
      });

      socket.on("ice-candidate", ({ from, candidate }) => {
        const pc = peerConnections[from];
        if (pc && candidate) {
          pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(err => {
            console.error(`[${from}] Error adding ICE candidate:`, err);
          });
        }
      });

      socket.on("user-left", ({ userId }) => {
        if (peerConnections[userId]) {
          peerConnections[userId].close();
          delete peerConnections[userId];
          const audio = document.getElementById("audio-" + userId);
          if (audio) audio.remove();
        }
      });
    }

    function createPeerConnection(userId) {
      const pc = new RTCPeerConnection(servers);
      negotiationLocks[userId] = false;

      pc.onicecandidate = e => {
        if (e.candidate) {
          socket.emit("ice-candidate", { to: userId, candidate: e.candidate });
        }
      };

      pc.ontrack = event => {
        let audio = document.getElementById("audio-" + userId);
        if (!audio) {
          audio = document.createElement("audio");
          audio.id = "audio-" + userId;
          audio.autoplay = true;
          document.body.appendChild(audio);
        }
        audio.srcObject = event.streams[0];
      };

      pc.onnegotiationneeded = async () => {
        if (negotiationLocks[userId]) return;
        negotiationLocks[userId] = true;
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          socket.emit("offer", { to: userId, offer });
        } catch (err) {
          console.error(`[${userId}] Negotiation error:`, err);
        } finally {
          negotiationLocks[userId] = false;
        }
      };

      return pc;
    }

    async function createRoom() {
      await initSocketConnection();
      await getMedia();
      const roomCode = Math.random().toString(36).substr(2, 6).toUpperCase();
      document.getElementById("roomCodeDisplay").textContent = "Room Code: " + roomCode;
      socket.emit("create", roomCode);
      socket.emit("ready", roomCode);
    }

    async function joinRoom() {
      await initSocketConnection();
      await getMedia();
      const roomCode = document.getElementById("roomCodeInput").value.toUpperCase();
      socket.emit("join", roomCode);
      socket.emit("ready", roomCode);
    }

    async function getMedia() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (err) {
        alert("Microphone access is required!");
        throw err;
      }
    }
  </script>
</body>
</html>
