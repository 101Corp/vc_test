<!DOCTYPE html>
<html>
<head>
  <title>Group Voice Chat</title>
</head>
<body>
  <h1>Group Voice Chat</h1>

  <input id="wssUrl" placeholder="Enter WSS URL (optional)" />
  <br><br>
  <button onclick="createRoom()">Create</button>
  <button onclick="joinRoom()">Join</button>
  <input id="roomCodeInput" placeholder="Enter room code..." />
  <p id="roomCodeDisplay"></p>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"
    integrity="sha384-mZLF4UVrpi/QTWPA7BjNPEnkIfRFn4ZEO3Qt/HFklTJBj/gBOV8G3HcKn4NfQblz"
    crossorigin="anonymous"></script>

  <script>
    let socket;
    let peerConnections = {};
    let localStream;

    async function initSocketConnection() {
      const url = document.getElementById("wssUrl").value || location.origin.replace(/^http/, 'ws');
      socket = io(url);

      socket.on("connect", () => console.log("âœ… Connected to server"));

      socket.on("user-joined", async ({ userId }) => {
        console.log(`[${userId}] joined`);
        if (peerConnections[userId]) return;

        const polite = false; // you're the one joining, you're impolite
        const pc = createPeerConnection(userId, polite);
        peerConnections[userId] = pc;
      });

      socket.on("offer", async ({ from, offer }) => {
        let pc = peerConnections[from];
        if (!pc) {
          // You're polite because you didn't initiate
          pc = createPeerConnection(from, true);
          peerConnections[from] = pc;
        }

        const isCollision = pc.makingOffer || pc.signalingState !== "stable";

        if (isCollision && !pc.polite) {
          console.warn(`[${from}] Ignoring offer due to collision`);
          return;
        }

        try {
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit("answer", { to: from, answer });
        } catch (err) {
          console.error(`[${from}] Error handling offer:`, err);
        }
      });

      socket.on("answer", async ({ from, answer }) => {
        const pc = peerConnections[from];
        if (!pc) return;
        try {
          await pc.setRemoteDescription(new RTCSessionDescription(answer));
        } catch (err) {
          console.error(`[${from}] Error setting answer:`, err);
        }
      });

      socket.on("ice-candidate", ({ from, candidate }) => {
        const pc = peerConnections[from];
        if (pc && candidate) {
          pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(err => {
            console.error(`[${from}] Error adding ICE:`, err);
          });
        }
      });

      socket.on("user-left", ({ userId }) => {
        if (peerConnections[userId]) {
          peerConnections[userId].close();
          delete peerConnections[userId];
          const audio = document.getElementById("audio-" + userId);
          if (audio) audio.remove();
        }
      });
    }

    function createPeerConnection(userId, polite) {
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      pc.polite = polite;
      pc.makingOffer = false;

      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      pc.onicecandidate = e => {
        if (e.candidate) {
          socket.emit("ice-candidate", { to: userId, candidate: e.candidate });
        }
      };

      pc.onnegotiationneeded = async () => {
        try {
          pc.makingOffer = true;
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          socket.emit("offer", { to: userId, offer });
        } catch (err) {
          console.error(`[${userId}] Negotiation error:`, err);
        } finally {
          pc.makingOffer = false;
        }
      };

      pc.ontrack = event => {
        let audio = document.getElementById("audio-" + userId);
        if (!audio) {
          audio = document.createElement("audio");
          audio.id = "audio-" + userId;
          audio.autoplay = true;
          document.body.appendChild(audio);
        }
        audio.srcObject = event.streams[0];
      };

      return pc;
    }

    async function createRoom() {
      await initSocketConnection();
      await getMedia();
      const roomCode = Math.random().toString(36).substr(2, 6).toUpperCase();
      document.getElementById("roomCodeDisplay").textContent = "Room Code: " + roomCode;
      socket.emit("create", roomCode);
      socket.emit("ready", roomCode);
    }

    async function joinRoom() {
      await initSocketConnection();
      await getMedia();
      const roomCode = document.getElementById("roomCodeInput").value.toUpperCase();
      socket.emit("join", roomCode);
      socket.emit("ready", roomCode);
    }

    async function getMedia() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (err) {
        alert("Microphone access is required!");
        throw err;
      }
    }
  </script>
</body>
</html>
